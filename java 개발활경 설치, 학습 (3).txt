java 개발환경 설치. + 학습

001--------------------------------------------------------------------------------------------

1. jdk 설치
-> 자바 개발환경 설정, 설치 
https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html
*모달창: 팝업창처럼 새로운창, 메인창은 비활성화됨, 모달창에 동의해야 다시 안생김.
계정 : park~gmail / D용 ~@
환경변수 - eclipse로 작업하기 때문에 안해도됨
cmd : java -version 확인

2. ide(eclipse 다운)  Enterprise (java는 SE-무료, 이클립스 Enterprise에서 어느정도 지원))
https://www.eclipse.org/

3. 자바 프로젝트 저장 공간
 - workspace_java

4. eclipse의 구조
 window - show view , new Window(창 다 닫혔을 때)
-> Package Explorer , Console
 window - Open Perspective - java Perspective

[ctrl + n]
 Java Project, JavaSE-1.8
HelloWorld(C:\workspace_java 에 디렉토리생성됨)
프로젝트 첫 글자 대문자, 띄어쓰기하지 않음, 띄어쓰는 단어의 첫 글자 대문자

 src - Java Package - 
Package(디렉토리) -도메인이름 뒤에서부터 소문자(com.naver / kr.co.ezen)

class
첫 글자 대문자, 띄어쓰기하지 않음, 띄어쓰는 단어의 첫 글자 대문자
main() 메서드 생성 -> main 적은 후 [ctrl + space]

console
[sysout] 적은 후  [ctrl + space]
println("hello world");
println(11);
println("A");

5. 콘솔에 "hello world" 출력
 console
[sysout] 적은 후  [ctrl + space]
println("hello world");
println(11);
println("A");

6. 변수(데이터) ,32가지? 암기!
 a = b; 
= 는 대입 연산자 -> b의 값을 a에 대입(같다 아님)(o), a를 b에 대입(x)
a -> 변수명(그릇)
b -> 값 or 변수 (b의 값이 사라지지 않음)

--
프로젝트(폴더, main한개, 첫대문자) -src- 패키지(폴더,소문자 도메인) - 클래스(첫 대문자)

github에 적용
githubstudy - javastudy 에 파일 넣기
cmd에서javastudy이동 파일 add, commit, push 
깃허브 로그인

002---------------------------------------------------------------------------------------

 변수!!
-----
메서드 생성
메서드 호출(사용)
------
main,class 스코프 - {_더블클릭
 } (파란선택영역)
-----

String name = "문자열";	 // 중복되는 문자열 변수선언
System.out.println(name);	//""없이 입력

변수 선언 공식
**자료형 변수명 = 자료형에 맞는 값;
--
// 변수 선언 공식
// 자료형 변수명 = 자료형에맞는값;
// 값에맞는자료형 변수명 = 값;
--

변수 차이 예)
String jin = "11";		// String 문자열 "11" 로 선언
int jin3 = 11;		// int 정수 11로 선언

System.out.println(jin+jin );		//출력 1111
System.out.println(jin3+jin3);		//출력 22


자료형(type)의 종류 (크게 두가지)
1. 기본자료형(primitive) 8가지.
- boolean : true, false
 (boolean a = true; or boolean a = false;)  

- char : 한 글자
 (char = '한';)

- 정수형(값의 범위가 중요), 형변환 (자료형)값 으로 사용 할 수 있다.
byte	(1byte=8bit)	-128~127	
short	
int	(4byte)		-21억~+21억 	42억(2의 32승)
long	(8byte)
*int (+-)21억, 정수형의 기본자료형
*long형에 맞는 값(약 21억 이상)은 숫자 뒤에 L/l을 써줘야 한다.

- 실수형(정밀도가 중요)
float : 값 뒤에 F/f를 써줘야 한다.
double : 실수형의 기본 자료형
BigDecimal


-> 참조자료형(referece) :  기본자료형이 아닌 자료형
MainEx me = new MainEx();
String msg = new string("hello");
String : "문자열"


변수선언은 자료형 변수명 = 자료형에 맞는 값; 이다

자료형은 기본자료형과 참조자료형으로 나뉜다
참조자료형은 기본자료형을 제외한 자료형이다
기본자료형은 논리,문자,정수,실수 8가지 이다
논리 자료형 boolean 은 true, false만을 값으로 대입할 수 있다
문자 자료형 char 은 문자 '한' 글자만 ''안에 적는다
정수 자료형은 값의 범위에 따라 4가지로 나뉜다
byte 는 -128~127까지의 범위를 갖는다 1byte(=8bit) 2^16
short 는 -32768~32767까지의 범위를 갖는다 2byte 2^32
int 는 정수형의 기본자료형으로 약 -21억~21억의 범위를 갖는다
long 는 int형의 범위를 초과하는 약 -22억 이하 +22억 이상의 값일 때 사용한다
lomg 는 마지막에 l/L을 적는다
실수자료형은 정밀도를 기준으로 나눈다
float보다 double이 더 정밀하다
float는 마지막에 f/F를 적는다
double는 실수형의 기본자료형이다

003 -------------------------------------------------------------------------------------------

참조자료형(reference type)의 변수 선언

자료형 변수명(reference) = new 자료형();   ->생성자(자료형();)
ex) String msg = new String("hello");
 
--
Dog class : 참조자료형 ,Dog dog = new Dog(); ->creat class 호출.
String class : 참조자료형
Command 인터페이스 : 참조자료형
int[ ] : 참조자료형
--
아스키코드(검색해보기)
--
기본자료형 =
수치형 자료형 : boolean 제외한 기본자료형
+ 
비수치형 자료형 : boolean
--
지역(local) 변수의 스코프: 선언 이후, 생성자 or 메서드의 스코프({}영역) 끝까지
지역변수: 메서드나 생성자, 제어문(if, for) 안에서 선언된 변수 (보안에 좋다)
	클래스의 필드 외에서 선언된 변수
	선언된 이후부터 해당 중괄호의 종료 표기까지( } )
멤버변수: 클래스 필드에 선언된 변수 , - 객채의 구성 요소

클레스 이름과 생성자(참조자료형) 이름은 같아야 한다.

일반적으로 지역변수는 선언과 동시에 초기화 - 자료형 변수명 = 자료형의 맞는값;
	  멤버변수는 선언만 한다 - 자료형 변수명; 
String master;
int i;
double d;

초기화: 변수 선언과 동시에 값을 대입하는 것.
int i = 0;
String master = "마스터";

=== 생성자? 메서드? 클래스필드?
package co.naver;
public class Cat {				
	//member 변수(클레스 필드에 선언된 변수)
	String name = "happy"; 
	int age;
	String addess;

	public Cat() {			// 생성자
		System.out.println(name);
		int b = 33;
		System.out.println(b);
		me1(); // 멤버들끼리는 순서가 중요하지 않다 
	}
	public void me1() {			//반환값이 없다, 메서드
		System.out.println(name);
	}
}
==
Object(모든 자료형을 포함) 
Object c;

생성자호출 - Test test = new Test();

생성자 public 클레스명과동일(){ }

자료형의 디폴트값
boolean는 false(0)
char는 빈칸
정수형은 0 
실수형은 0.0
참조자료형 디폴트값은 null(값이 없음)

1. 지역변수의 개념
 - 메서드나 생성자 안에서 선언된 변수
 - 선언위치 부터 해당 변수 영역끝( } )까지 사용
2. 지역변수의 스코프에 대해서 깊게 학습
 - 선언 위치 ~ 해당 변수가 선언된 곳의 } 까지
3. 초기화
 - 변수를 선언할 때 값을 같이 입력해주는 것
 - 초기화 예제) int a =3;
 - 초기화를 하지 않은 예제) int = b;
*멤버변수초기화는 생성자 안에서만 한다.
4. 멤버변수의 개념
 - 클래스의 멤버로 선언된 변수
 - 생성자나 메서드의 밖에서 선언된 변수
 - 클래스 전체에서 사용
 - 일반적으로 private 으로 선언함.
 - private: 같은 클래스에서만 접근가능
5. 멤버변수의 일반적인 사용
 -초기화하지 않고 선언만 함
 - int a;
 - Dog d;
6. 멤버변수의 디폴트값
 - boolean - false
 - char - 공백
 - 정수형 및 실수형 - 0
 - 참조자료형 - null
7. (변수)대입: 반드시 변수가 선언된 후에만 가능
 *변수 선언과 동시에 값을 넣으면 초기화, 선언이후에 값을 넣으면 대입.
 - 변수명 = 자료형에 맞는 값;
 - 예 a = 10;

 int a =44; <<초기화
 a = 44; << 대입

메서드(함수) ! 

void =반환값이 없을 때
반환형 : 반환되는 데이터(값)의 자료형

004----------------------------------------------------------------------------------

static(특별함?)
literal: 상수, 대입의 대상이 될수 없다.

메모리 영역 할당 
/method//stack//heap        /
method : 
stack : 힙 메모리의 주소 값(int형) // 인트 자료형 변수 선언의 대입되는 값
heap : 객체(참조자료형의 값) // new MerhodTest();
Dog d = c; (이렇게 주소값만 넘겨줄 수도 있다)

생성자 
-> public className(){ } 디폴트 생성자 // 객체를 생성

메서드 
-> publric void Name(){ } 무반환 무파람 메서드 // 객체의 기능
-> 객체의 기능, 행위, 능력을 의미(java에서는 함수), 중복 코드를 묶어주는 역할

ex)
public class MethodTest {
public MethodTest() {} --> 객체 생성, 생성자
public void sleep(){} --> 객체 선언, 메소드
                          --> 무반환(void) 무파람(괄호가비어있음)
public (접근제한자)
-> 프로젝트 전체에서 sleep메서드가 호출될 수 있음을 의미

void (반환형: 반환되는 데이터의 자료형) 
-> 반환되는 데이터가 없다는 의미

sleep (메서드의 이름) 
-> 메서드 호출 시, 이름을 적음으로 메서드 본문 코드를 실행하게함

( ) (파라미터, 매개변수 선언하는 곳)
-> 변수를 선언하듯 작성. 파라미터가 두개 이상일 때는 ,를 구분자로 구분

{} (메서드의 본문)
-> 메서드 호출 때 실행하고 싶은 코드 작성
}


메서드 선언공식
접근제한자 반환형 메서드명(파라미터자료형 파라미터변수) { 
	메서드 호출 시 실행 코드
}
ex) 메서드 선언
public MethodTest(){
	 public void callName(String name) { 
	 System.out.println(name);
	 }
}
ex) 메인 클레스에서 호출
 MethodTest m1 = new MethoTest();
 m1.cllName("홍길동");


메서드의 종류

1. 무반환(void) 무파람 : void, 파라미터가 ( )
 //메서드 생성 ex)
public void callName(){
     System.out.println("무변환 무파람");
}

2. 메서드 호출 
-> 메서드를 사용하는 것을 의미
-> 메서드명을 적고 소괄호, 그 소괄호 안에 파라미터의 자료형에 맞는 값을 입력

 2.1 같은 class 호출 : 메서드명() 
-> ex) callName();		// 메서드 호출

 2.2 다른 class 호출 : 객체생성 후 객체명.메서드명();
-> ex) MethodTest mt = new MethodTest();  //객체 생성
         mt.callName();			// 메서드 호출

3. 무반환 유파람(파라미터 있음)

3.1 메서드 생성
 class [ MethodTest ]에서 printScore(String name) 메서드 생성 
-> 메서드 파라미터에 자료형(String)과 변수명(name)을 작성

// 메서드 생성 ex)
public void printScore(String name, int score){
     System.out.println(name + " " + score + "점")
}

3.2 메서드 호출
 객체 생성 후
mt.printScore(자료형에 맞는 값)	//메서드 호출 (자료형에 맞는값)

// 메서드 호출 ex)
1) 같은 class
﻿printScore("홍길동", 100);

2) 다른 class
MethodTest mt = new MethodTest(); //객체 생성
mt.﻿printScore("홍길동", 100); // 메서드 호출﻿

005--------------------------------------------------------------------------------------------

개념 참고 http://tcpschool.com/java/intro

클래스 = 설계도
객체(변수) = 실체
변수 = 구성요소(핸들, 이름), 
메서드 = 기능,능력(가속하기)
생성자(constructor) = 객체 선언, 객체의 맴버변수의 초기화, 리턴값 없음(void 안쓴다)
지역변수 = 외부에서 접근불가, 보안에 강하다
멤버변수(field) = 외부에서 접근가능
매개변수(parameter) = 메서드에 넘겨줄 값, ()안에 기술
값을 반환 return (반환자료형에 맞는 값);

3. 유반환 무파람
3.1 참조변수 반환
public Test12 getTest12() {			//Test12(반환자료형)
		return new Test12();
	}

MethodTest3 mt7 = new MethodTest3();	//클래스이름 객체변수명 = new 클래스이름(생성자) -->인스턴스(객체)생성
		Test12 re4 = mt7.getTest12();	// 반환자료형 변수명 = 객체변수명.메서드명

3.2 기본자료형 반환
public int getTest13() {
		return 99;
	}

MethodTest3 mt8 = new MethodTest3();	//인스턴스(객체) 생성, 클래스가 메모리에 생성
		int re5 = mt8.getTest13();


006--------------------------------------------------------------------------------------------------------------------
- TEST -

1. 자료형의 종류를 기술하시오.
자료형은 기본자료형과 참조자료형으로 나뉜다
참조자료형은 기본자료형을 제외한 자료형이다
기본자료형은 8가지로 boolean, char, byte, short, int, long, float, double이 있다

2. 정수형 변수 a에 자료형에 맞는 값 중 하나를 적으시오.
-33

3. long 형에 맞는 값 중 하나를 적으시오.
2400000000L

4. float 형에 맞는 값을 하나 적으시오.
3.14f

5. boolean  형에 맞는 값 두 개르를 적으시오.
true
false

6. char 형에 맞는 값을 하나 적으시오.
'a'

7. Dog형에 맞는 값을 하나 적으시오.
new Dog()

8. String 형에 맞는 값을 하나 적으시오.
"홍길동"

9. Cat형에 맞는 값을 하나 적으시오.
new Cat()

10. Pig형에 맞는 값을 하나 적으시오.
new Pig()

11. Car형에 맞는 값을 하나 적으시오.
new Car()

12. Apple형에 맞는 값을 하나 적으시오.
new Apple()

13. 클래스 Dosirak의 디폴터 생성자를 적으시오.
public Dosirak(){
}

14. 클래스 Gost의 디폴터 생성자를 적으시오.
public Gost(){
}

15. 클래스 Member의 디폴터 생성자를 적으시오.
public Member(){
}

16. 무반환 무파람 메서드 showMetheMoney( )를 작성하고 호출 코드도 작성하시오.
     - 단, 실행 내용은 "500원" 출력
     - 단, showMetheMoney( )는 Bank클래스의 메서드이다.

public Bank(){	
}
public void showMetheMoney(){
	System.out.println("500원");
}

main에서 호출
Bank bank = new Bank();
bank.showMetheMoney();

17. 무반환 유파람 메서드 setName( )를 작성하고 호출 코드도 작성하시오.
    - 단, 실행 내용은 this.name = name;		
    - 단, setName( )는 Member클래스의 메서드이다.

private String name;		// 필드에 선언
public Member(){
	 
}
public void setName(String name){
	this.name = name;		//this는 객체 자기자신을 의미
}				//지역변수와 멤버변수가 같을 때 지역변수가 우선(그래서 this.을 사용)

main에서 호출
Member member = new Member();
member.setName("홍길동");

18. 유반환 무파람 메서드 getBoard( )를 작성하고 호출 코드도 작성하시오.
    - 단, 실행 내용은 Board클래스의 객체를 반환한다.
    - 단, getBoard( )는 Board클래스의 메서드이다.

public Board(){
}

public Board getBoard(){
	return new Board();
}

main에서 호출
Board board = new Board();
Board b1 = board.getBoard();

- TEST End -


4. 유반환 유파람

private String carName; 
field(멤버변수)는 private로 선언 외부에서 접근 불가
외부에서 접근하기 위해 get~, set~ 메서드 필요
get, set 메서드는 이클립스에서 마우스 우클릭(source - Generate Getters and Setters) 에서 해당 필드 체크
혹은 직접입력
public String getCarName() {
		return carName;
	}

public void setCarName(String carName) {
		this.carName = carName;
	}

파라미터 입력, 리턴 (기능수행) 반환

파라미터가 있음으로 동적실행가능(입력값이 변함)

// 메서드 기본 4유형 
	
	// 1. void(return 값 없음), 매개변수 없음
	public void me1() {
		
	}
	
	// 2. void(return 값 없음), 매개변수 있음
	public void me2(String name, int age) {
		
	}
	
	// 3. return(참조자료형) 있음, 매개변수 없음
	public Dog me3() {
		return new Dog();
	}
	
	// 4.return(정수형) 있음, 매개변수 있음
	public int me4(String name) {
		int size = name.length();
		return size;
	}

// 메서드 4유형 호출
		
	Dog hot = new Dog();
		
	// 1. void(return 값 없음), 매개변수 없음
	hot.me1();
		
	// 2. void(return 값 없음), 매개변수 있음
	hot.me2("핫도그", 2);
		
	// 3. return(참조자료형) 있음, 매개변수 없음
	Dog hotDog = hot.me3();
		
	// 4.return(정수형) 있음, 매개변수 있음
	int gotDog1 = hot.me4("갓도그");
	int gotDog2 = hot.me4(new String("갓도그"));
	

007-------------------------------------------------------------------------------

5. 메서드 오버로링

* 파라미터의 개수or자료형or순서가 다르면 성립*

5.1 선결 조건(and)
- 같은 클래스에서 생선된 메서드
- 메서드의 이름이 같을 것
* 파라미터의 개수or자료형or순서가 다르면 성립*
- 접근제한자, 반환형, 파라미터의 변수명, 메서드 본문내용은 관련 없음

5.2 메서드 오버로딩 성립 조건(or)
- 파라미터(매개변수)의 개수가 다르면 성립
	public void m1(){}
	public void m1(int a){}
- 파라미터의 개수가 같고, 파라미터의 자료형이 다르면 성립
	public void m1(int a, long b){}
	public void m1(int a, dog c){}
- 파라미터의 개수가 같고, 파라미터의 자료형도 같을 때 파라미터 자료형의 배치 순서가 다르면 성립 
	public void m1(int a dog c){}
	public void m1(dog c, int a){}

5.3 메서드 오버로딩을 사용
- 메서드들의 전반적인 기능이 같은데 파라미터의 자료형이 다를 때
- 장점: 메서드 호출 시 파라미터의 자료형에 구애받지 않고 호출

==메서드 오버로딩 Vs 메서드 오버라이딩에 대해 설명.

6. 메서드 오버라이딩 (추후에)
- 상속 관계가 성립하는 두 클래스에서 자식 클래스가 부모 클래스의 메서드 내용을 재정의 하는 것을 의미
- 재정의: 수정/삭제/추가 

==오버로딩과 오버라이딩의 차이

﻿+ 생성자
- class의 field를 초기화하는 class의 구성요소
- new 생성자(); 호출할 때 마다 객체 생성(객체 = 변수명 = 레퍼런스)
- 접근제한자 생성자명(){}  // 생성자명은 클래스명과 같다,
- [Ctrl + Space + Enter 디폴트생성자]
- 디폴트 생성자와 사용자 생성자로 나눈다

+생성자의 기능
- 클래스 멤버변수 초기화
- 참조자료형의 자료형에 맞는 값을 제공
- 반환형이 없다

+ 디폴트 생성자
- 파라미터가 없는 생성자
- 클래스에 생성자가 없으면, 디폴트 생성자 제공
- 클래스에 사용자 생성자가 있으면, 디폴트 생성자 미제공
super(); // 생략되어있음.(보이지 않지만 존재)
- Ctrl + Space로 바로 만들 수 있다

+ 사용자 생성자
- 파라미터가 있는 생성자
- 우클릭(Shift + Alt + S) Source - Generate - Constructor - Using - fields - 체크
*사용자 생성자가 있으면 디폴트 생성자는 지원되지 않음

+ 생성자 공식
접근제한자 생성자명(){}
-생성자명은 클래스명과 같다

this.변수명
- 해당 클래스의 field를 가르킴(객체 자기 자신)
- 지역변수와 field가 같을 때 지역변수를 우선인식해서 this.를 쓴다
this()
- 다른 생성자 호출
- 생성자가 오버로딩되면 생성자 간의 중복 코드가 발생할 때 사용
- 초기화 내용을 한 생성자에 몰아서 작성
- this(변수1, 변수2, 변수3....);
- this(); 디폴트 생성자 호출
- 생성자 본문 첫 줄에서만 사용가능(그래서 메소드호출이 더 많이 사용됨)

﻿생성자 선언에 다른 생성자가 들어갈 경우
연습 문제)1

public Person(String name, String ssn, String address, int dateOfBirth, Car car, Dog dog, Cat cat) {
	...	this.car = car;
		this.dog = dog;
		this.cat = cat;

Person park = new Person("박씨", "m-01", "경기도", 901223, new Car("승용차"),new Dog(), new Cat());

연습 문제)2
Person kim1 = new Person("s01", new String("kim"), 44, "서울", "lec", new Dog("개똥이", 55, "개주인"), null);
		Person park = new Person("a12", "박", 31, "서울", "학생", new Dog("멍멍이", 3, "주인박씨"), null);
		park.setAge(99);
		park.getDog().dogInfo();
		
		park.setDog(new Dog("두부", 5, "박씨"));
		park.getDog().setName("잔디");
		String dogName = park.getDog().getName();
		System.out.println(dogName);
		park.getDog().dogInfo();
		kim1.getDog().dogInfo();
			

10.26)008-------------------------------------------------------------------------------------------------

= 클래스의 구성 요소 =
- 멤버 변수
 필드영역에서는 변수 대입이 불가.
 필드영역에서는 메서드 호출 불가.

- 생성자

- (멤버) 메서드
 메서드 영역에서 메서드 생성 불가.(호출은 가능)

* 멤버변수나 메서드를 호출(사용)하려면, 반드시
객체(=해당 변수나 메서드를 포함하고 있는 참조자료형 변수)가 있어야 한다.

1. 생성자의 역할
- 멤버 변수의 초기화
- 객체(=참조자료형의 변수)의 생성 때, 자료형에 맞는 값으로 사용됨.
- Ctrl + Space로 바로 만들 수 있다

2. 멤버 변수의 역할
- 객체의 구성요소를 표현

3. 지역 변수
- 메서드 안에서 중복되는 값을 표현(수정 용의)

4. 메서드의 역할
- 객체의 기능(능력)을 표현
- 클래스 안에서 중복되는 값들(복수형)을 표현

5. 디폴트 생성자(무조껀 만든다)
- 사용자 생성자가 없을 때는 존재
- 사용자 생성자가 있을 때는 없다

6. this
- 객체 자기자신
- 지역 변수와 멤버 변수가 이름이 같으면 지역변수를 우선인식하기 때문에 사용
- this.멤버변수

this( ) 
- 생성자 호출
- 해당 클래스 안에서만
- 다른 생성자의 첫번째 라인에서만 호출 -> 대신 메서드를 사용, 제약이 없음

=========

= 객체와 클래스

Object = 자바의 최상위 부모클래스

객체 = object(오브젝트) = instance(인스턴스) [= bean(빈) = entity = domain]

1. 객체는 명사다.
 - 한라산
ex) Mountain hanlasin = new Mountatin("한라산");

 - 자동차
ex) Car bmw = new = Car();

2. heap 메모리에 저장된 데이터

3. 실체


4. 객체 생성법
- 참조자료형 변수명(=객체명=레퍼런스) = new 생성자();
5. 객체 사용법
- 객체가 갖고 있는 자원(변수, 메서드)을 사용하는 방법
-> 객체명.변수명
-> 객체명.메서드명()
-> 객체명.상수명;
- 같은 객체를 여러번 호출 하여 사용할 수 있다.

= 클래스(= 객체의 설계도)

1. 객체의 구성 요소를 표현한 자료 - 멤버변수/상수
2. 객체 생성법을 표현한 자료 - 생성자
3. 객체의 기능을 표현한 자료 - 메서드

4. 설계도
ex) 붕어빵틀(클래스) : 붕어빵(객체)
ex) 자동차설계도(클래스) : 자동차(객체)

5. 클래스의 구성 요소
멤버 필드(변수/상수), 생성자, 메서드

6. 클래스는 단독으로 실행되지 않는다. 
 -> 객체를 생성하여 작업할 수 있다.

7. class 키워드가 있어야 클래스이다.
 (상속에서 익명의 내부클래스가 있다, class키워드가 없는 익명)


10.27)009----------------------------------------------------------------------

String
charAt(int ide) = 인덱스, 문자열의 n번째
ex) charAt(0)
-> String charCap = captain.getK7().getModelName();
		char c = charCap.charAt(0);

// 멤버1이 갖고 있는 개를 외부에서 입력하는 개로 변경
	public void changeMember1Dog(Dog dog) {
		member1.setHappy(dog);
	}
// 멤버1이 갖고 있는 개의 이름을 외부에서 입력하는 이름으로 변경
	public void changeMember1DogName(String dogName) {
		member1.getHappy().setName(dogName);
	}

인스턴스 변수
새로운 객체 생성시 힙메모리에 만들어진 변수
객체가 만들어질 때 마다 새로만들어짐
각각 고유한 값을 갖는다

new Date(n)
1970년 1월 1일 0시 0분 0초 000 --> date(0)
1970년 1월 1일 0시 0분 0초 001 -->1
1970년 1월 1일 0시 0분 1초 000 -->1000

new Date()
현재시각

new Date(Calendar.getInstance().getTimeInMillis())
현재시각(수정가능)


aTeam.fight(bteam); 

-> fight에 밑줄
-> 먼저 선언후 creat method 'fightMem3(bteam)' in Type 'Team'

===
연습문제)
public void fight(Team otherteam) {
		String aTeamCaptainName = this.captain.getName();	//호출한 메서드
		String bTeamCaptainName = otherteam.captain.getName();
		System.out.println(aTeamCaptainName+"과 "+ bTeamCaptainName+"이 싸운다");

System.out.println("활로 " +mon.toString()+" 를 공격합니다.");
-> mom (mom.toString() 이 생략되어있다)
	

		Monster mon = new Monster();
		Bow bow = new Bow();
		
		Hero hero = new Hero(bow);
				
		hero.attack(mon);
		hero.attack(mon);
		
		
		Sword sword = new Sword();
		hero.attack(sword, mon);
		hero.attack(mon);
		
		Spear spear = new Spear();
		
	//	hero = new Hero(spear);
		
		hero.setSpear(spear);	//창spear을 추가해줌
	//	hero.setBow(bow);
		
	//	hero.attack(spear, mon);
		hero.attackSpear(mon);
		hero.attack(mon);

ex) 클레스 내부에서 같은 클래스 호출 가능 aTeam, bTeam
main
aTeam.fight(bteam);
class
public class Team {
	
	private Person captain;
	private Person member1;
	private Person member2;
	
	public Team() {
		// TODO Auto-generated constructor stub
	}
	
	
	public Team(Person captain, Person member1, Person member2) {
		super();
		this.captain = captain;
		this.member1 = member1;
		this.member2 = member2;
	}
public void fight(Team otherteam) {
		// TODO Auto-generated method stub
		String aTeamCaptainName = this.captain.getName();	//호출한 메서드
		String bTeamCaptainName = otherteam.captain.getName();
		System.out.println(aTeamCaptainName+"과 "+ bTeamCaptainName+"이 싸운다");
		
	}
}


=== 연산자

사칙연산
+, -, *, /

산술연산자
+, -, *, /, %

+
문자열 연산이 가능

-
a = 1 - a ; 를 이용해 스위치 연산 가능

*
연산후 자료형의 표현범위를 넘는지 검사해야 한다

/ 
나누기 연산자
0000111122223333... i/n+k
i== i++
n==반복되는 수의 개수 (0000 -> 4개)
k==시작값
같은 숫자가 n번 반복되면 /연산자
ex) 222333444555... -> i/3+2
ex) 778899101011... -> i/2+7
ex) 15,15,15,15,16,16,16,16... -> i/4+15

% 
﻿나머지연산자
012345012345012345... i%n+k
i== i++
n==반복되는 증가값의 개수 (012345 -> 5개))
k==시작값
특정 범위의숫자가 계속 반복되면 %연산자
ex) 56789/5678956789... -> (i%5)+5
ex) 9,10,9,10,9,10... ->(i%2)+9
ex)73,74,75,76,77,73,74,75,76,77... ->(i%/5)+73
﻿
﻿
% 연산자 사용예)
배수 구할 대 사용함(나머지가 0이면 배수)
소수를 구할때 사용한다(소수: 1과 자기자신을 제외한 약수가 없는 수)
게임 움직임 처리: 기러기 날개짓 이미지(01230123...)

=== 대입연산자
=
대입연산자는 항상 오른쪽에 있다

 복합연산자(산술연산자+대입연산자)
+=, -=, *=, /=, %=
a+=b -> a = a+b;
b+=a -> b = b+a;
a*=b -> a= a*b;
a/=b -> a= a/4;
a%=b -> a= a%b;

10.28)010------------------------------------------------------------------------

=== 비교 연산자
 >, >= , <, <= , == , !==
 연산 결과는 true, false (boolean)
 좌측을 기준으로 사용한다. ex)a>b, a는 b보다 크다.

>
 크다 | a>b -> a는 b보다 크다 (좌측 우선)

>=
 크거나 같다

<
 작다

<= 
작거나 같다

== 
같다  a==b a는 b는 같다

!= 
안 같다

 ==이나 !=은 boolean형 값을 비교 할 수 있다.
(true,false는 <,>등 크기비교는 안되지만 ==, != 는 할 수 있다.)

=== 논리 연산자
 &&, ||, !
 연산 결과는 true, false (boolean)

&&	
앤드앤드(그리고) 연산에 참여한 데이터 모두가 true 이면 true, 나머지는 false
 a && b		t2.k1(true, true); --> true
		t2.k1(true, false); ->false
		t2.k1(false, true); ->false
		t2.k1(false, false) ;->false

||	
오아오아(또는) 연산에 참여한 데이터 모두가 false 이면 false 나머지 true
 a || b		t2.k2(true, true); -> true
		t2.k2(true, false); -> true
		t2.k2(false, true); -> true
		t2.k2(false, false); -->false

!	
낫(아니,반대) true는 false로 false는 true로 바뀐다.
 !a		a = true; --> false
		a = false; --> true


=== 증감 연산자(단항 연산자)
1씩 증가, 1씩 감소
++ --

++a;
++이  변수 앞에 오면, 변수의 값이 1만큼 증가
그리고 그 증가된 값은 곧바로 변수에 대입
﻿ex) ++1 = 2
int t=5;
a = ++1 + t , syso(a); =>7

﻿
b++;
++이 변수 뒤에 오면, 변수의 값이 1만큼 증가
그러나 그 증가된 값은 나중에 해당 변수를 호출할 때 대입된다.
﻿ex) 1++ = 1
int t=5;
a= t + 1++ , syso(a) => 6

﻿1++ = 1
++1 = 2

a= a++;과 같이 사용하지 않는다.

a--;
스위치


=== 조건 연산자(삼항 연산자)
 조건문 보다 연산 속도가 빠르지만 가독성이 떨어져 유지보수가 힘들다.

변수명= a > b ? true일때 : false일때;
(자료형) 변수명 = 조건식(이 참인가) ? 참일때의값(or변수or반환형이있는메서드): 거짓일때의값(or변수or반환형이있는메서드);
조건식 -> 결과값이 true와 false

ex) 		int aa=3;
		int bb=5;
		int c = aa==bb ? 44 : 33;
		syso(c); -> 33
ex)
		/* 
		a와 b는 멤버변수.
	   	변수 c는 
		a가 b보다 크거나 같으면 'a'
		그렇지 않으면 'z'를 갖는다
		변수 c를 선언하시오
		*/
		char c = a>=b ? 'a' : 'z';

변수명 = 조건식1? 참일때의값: 조건식2?:참일때의값2:조건1,2,가 모두 거짓일때의 값;
-> 다중 if문과 같이 표현할 수도 있다
 조건문 보다 연산 속도가 빠르지만 가독성이 떨어져 유지보수가 힘들다.

=== 비트 연산자
0과 1을 사용

﻿&
AND : 2진수로 비교
1,1 이면 1 , 나머지는 0
(모두 1일 때 1)

|
OR : 2진수로 비교
0,0 이면 0, 나머지는 1
(하나라도 1일 때 1)

^
XOR, 배타적 OR, 익스클레시브 OR
같으면 0, 다르면 1
(하나만 1일 때 1)
두 값이 같은지 판별할 때 사용

~
NOT : 부호 반전
양수에서 음수 : +1
음수에서 양수 : -1
﻿ex)	 ~(00000000 00000000 00000000 00001110)
	== 10000000 00000000 00000000 00001110 

시프트 연산자
>>
라이트 시프트 연산자 : 숫자가 줄어든다
2진수가 오른쪽으로 한칸씩 옮겨진다. 
 2^n 승으로 나눔(나머지 버림)
ex)		  i >> n ==  i/2^n
		111000 >> 2 == 1110(2진수)
		14 >> 1 == 7 
		14 >> 2 == 3
		
<<
레프트 시프트 연산자 : 숫자가 증가한다
2진수가 왼쪽으로 한칸식 옮겨진다
 3*2^n승
ex) 		 i << n == i*(2^n)
		111000 << 2 == 11100000(2진수)
		3 << 1 == 6
		3 << 2 == 12

연산자 29
 대입연산자1 =
 산술연산자5 + - * / %
 복합연산자5 += -= *= /= %=
 비교연산자6 < <= > >= == !=
 논리연산자3 && || !
 증감연산자2 ++ --
 조건연산자1 자료형 변수명 = 조건식 ? 트루: 펄스;
 비트연산자4 & | ^ ~
 시프트연산자2 >> << 

10.29)011-------------------------------------------------------------------------------------

 조건문

[if else]

단순 if문(if)
 : ~ 하면 실행	//~에 조건식 

if else문(if else)
 :	 ~ 하면 실행, 
	그렇지 않으면 실행 (조건연산자(삼항연산자)와 비슷)

다중 if문
if else if else if else ...
: 	~이면(if) ~실행, 
	그렇지 않고(else) ~이면(if) 실행,
	그렇지 않고(else) ~이면(if) 실행, 
	그렇지 않으면(else) 실행

if(조건식1){
	실행1 : 조건1이 참이었을 때
}else if(조건식2){
	실행2 : 조건2가 참이었을 때, 실행2
}else{
	실행3 : 조건1과 조건2(위의 모든 조건)를 만족하지 않았을 때
}
실행1,2,3 중 하나만 실행하고 if문 밖 다른 걸 수행
조건식 실행부분에 return; // 해당 메서드를 바로 종료 

ex)
	public void chDown() {
		if(!power) {
			return; //해당 메서드 종료
		}
		--ch;	//return을 실행 했다면 아래 --증감연산자와 if은 사용하지 않음
		if(power&&ch<0) {
			ch=999;
		}
	}

[switch ~ case]

연산자를 사용하지 않음
- 내부적으로 ==을 수행함
- key == value (키와 벨류가 같나 비교)
int, String, enum 자료형만 사용가능

switch 컨트롤 + 스페이스
switch(변수 또는 변수 연산){
	case 값1:
		변수 == 값1일 때, 실행할 코드
		break; //break는 상황에 따라 운용하라.
 			//break는 switch~case문을 빠져나가라는 의미
	case 값2:
		변수 == 값2일 때, 실행할 코드
		break;

	default:
		모든 조건이 false일 때, 실행할 코드
		break;
}
switch (key) { /*코드입력불가*/
/*코드입력불가*/	case value:
			
			break;

		default:
			break;
		}
	} 

key
연산식이나 변수 입력
int, String, enum 자료형만 사용가능

{와 case 사이에 코드입력 불가

case
케이스는 if처럼 여러개 사용 가능

value
1,2,3..등 key와 ==을 비교할 값 입력

:
이 뒤에 실행문 입력

default:
모든 조건이 일치하지 않을 때
if문의 else와 같다

break;
스위치를 빠져나감
만날 때까지 참인 조건문의 실행을 순차적으로 실행함
브레이크 생략 가능
생략하면 다음 브레이크 까지 참인 조건문 실행

break;와 return;의 차이점
break;는 해당 스위치를 빠져나오고 해당 메서드 다음 기능 수행
return;은 해당 메서드를 종료. return; 후술 기능 수행하지 않음

 알고가기_ 알고리즘
치환 알고리즘
a와 b의 값을 서로 교환(잠깐 담을 수있는 변수 c가 필요)

누적 알고리즘
멤버변수에 해당 변수를 계속 누적시킴
ex) sum += a;
 
 알고가기_ 자바에서 중복코드 묶기
메서드 내에서 중복되는 데이터가 있으면 -> 변수
클래스 내에서 각 메서드 중에 중복되는 코드가 있으면 -> 메서드(함수역할)
프로젝트 내에서 각 클래스 중에 중복되는 코드가 있으면 -> 상속

10.30)012---------------------------------------------------------------------------------------------------

return의 사용
- 값의 반환 ex) return a;
- 메서드의 종료 ex) return;
ex)
메서드{
	if(조건){
	retrun;
	}
	메서드 실행1
	메서드 실행2
	...
}
리턴으로 메서드 종료조건(or실행조건)을 만들 수 있다.
ex) 	파워메서드가 펄스이면, 볼륨메서드는 실행하지 않는다.
	파워가 트루일때 볼륨을 실행한다. 

반복문
특정 코드들을 반복

break: 가장 가까운 반복문을 빠져나감.
continnue: 가장 가까운 반복문의 해당 회차만 빠져나감 (증감식으로 감.)

for문
- 몇회 반복할지 알고 있을 때 사용.

for(초기화; 조건식; 증감식){
 실행문
}

for문 연산 순서 : 
초기화 -> 조건식 -> 
(실행 -> 증감식 -> 조건식) -> 
(실행 -> 증감식 -> 조건식) ->
(실행 -> 증감식 -> 조건식) ->....(조건이 만족하지 않을때 빠져나옴)
초기화는 1회 후
조건식이 맞지 않으면 바로 나옴
조건식이 맞으면 실행문
실행문 다음에는 초기화로 가지 않고 증감식으로 간다.
그리고 다시 조건식으로 true, false를 판단

for문의 조건식
true이면 실행문으로  false이면 if문을 빠져나옴
반복횟수를 의미함
ex) (i=0;i<10;i++) 10번

증감식의 종류에 따라 < , >=를 주로 사용
++이면 i<n;
-- 이면 i>=n;

다중 for문은
 for문을 메서드로 호출해서 구현

소수
:1과 자기자신 외에는 약수가 없는 수
(n%n==0 && n%1==0) 만 있어야 소수
소수를 판별 하려면
n%i~n ==0 인것이 자기자신일 경우(1은 초기화값에서 제외)

[연습문제]
1. 소수 검사
 1과 자기자신 외에는 약수가 없는 수
(n%n==0 && n%1==0) 만 있어야 소수
소수를 판별 하려면
n%i~n ==0 인것이 자기자신일 경우(1은 초기화값에서 제외)

	public void sossu(int num) {// 정수 넘겨 받기
		for(int i=2;i<num;i++) {// 2 ~ num 바로 앞 숫자 까지 약수확인(1과 자기 자신 빼고 검사)
			if(num%i==0) {		// 나머지가 0이면 약수
				System.out.println(num+"은 소수 아님");//약수면 소수아님
				break;			//약수를 찾으면 else if는 패스
			}else if(i==num-1) {//약수가 없을 때 넘 바로 앞까지 다 검사한건가?
				System.out.println(num+"은 소수 이다.");//약수가 없다면 소수
			}
		}
	}

2. 피라미드 찍기
2.1 정수를 넘겨받아 '*'를 n개 출력
2.2 첫번째 줄 1개 두번째2개 3번째 3개 ... n번째 n개 출력
2.3 1개 부터 점점 증가해서 n번째 부터 1개까지 감소하게 출력

	public void star(int num) {			//2.1
		for(int i=0;i<num;i++) {
			System.out.print('*');
		}
		System.out.println();
	}
	
	public void star2(int num) {		//2.2
		for(int i=0;i<num;i++) {
			star(i+1);
		}
	}
	
	public void star3(int num) {		//2.3
		for(int i=0;i<(num*2);i++) {
			if(i+1<num/2) {
				star(i+1);
			}else {
				star(num-i-1);
			}
		}
	}

3. 구구단 출력
3.1입력받은 숫자 n단 출력
3.2 3.1을 호출해서 1~9단까지 출력
3.3 1~4단까지 가로로 출력 그 아래 5~9단까지 가로로 출력

	public void mTable(int num) {
		for(int i=1;i<10;i++) {		//곱셈은 1부터
			System.out.printf("%dX%d=%d%n",num,i,num*i);
		}
	}
	
	public void mTable2() {
		for(int i=2;i<10;i++){		//2단 부터
			System.out.println(i+"단");
			mTable(i);
		}
		
	}
	
	public void mTable3(int k, int n,int j) {  //k~n단까지
		for(int i=k;i<n;i++) {
			System.out.print(i+"x"+j+"="+(i*j)+"\t");
		}
		System.out.println();
			
		
	}
	public void mTable4() {
		for(int j=1;j<10;j++) {
			mTable3(2, 6, j);	//2~5단까지 
		}
		System.out.println();
		for(int j=1;j<10;j++) {	
			mTable3(6, 10, j);	//6~9단까지
		}
			
	}

11.02)013-------------------------------------------------------------------------------------------------------------

return; 메서드 중단
break; 가장 가까운 반복문 중단, 조건문 중단
continue; 가장 가까운 반복문의 해당횟수 중단 후 for(증감식)으로 , while(조건식으로감)


do ~ while
코드가 만족하지 않아도 1번 실행 후 종료

while문
 (참이면 계속) ~하까지 계속!
어떤 조건(어떤 값 까지)으로 그만두게 할 것인지 알 때
1.변수 선언 및 초기화
2. while(조건식)
3.{ 트루일 때 실행될 코드
4. 증감식 }
whlie문의 증감식은 i값에 대입으로 한다.
ex)
	public void dan(int dan) {
		int i=1;
		while(i<10) {
			StringBuffer sd = new StringBuffer(dan);
			sd.append(dan);						
			sd.append("x");
			sd.append(i);
			sd.append("=");
			sd.append(dan*i);
			String msg = sd.toString();
			System.out.println(msg);		// sd.append(); 가 순서대로 toString();에 들어감	
	//		System.out.println(dan+"x"+i+"="+i*dan);	이것과 동일
			i++;
	}

=== staic
static 변수(상수/메서드) =(같다) class 변수(상수/메서드) = 정적 변수(상수/메서드)

***(중요) 프로그램이 실행되면, 곧바로 static 영역(메서드(클래스) 메모리)에 로딩이 되어 실행 가능한 상태가 된다
객체를 선언하지 않고 사용가능.

static 변수, 상수
- 무조건 1개만 생성(=객체마다 값이 변하지 않는다, 인스턴스변수와의 차이) 
- (변하지 않는다, 클래스마다 1개씩)

생성공식
public(접근제한자) static type 변수명;
ex) public static int a;

접근(호출) 방법
static 변수
- class명.변수명
ex) Test.a = 200; 
 - Test t1=  new Test();
 - Test t2 = new Test();
 -> t1.a 와 t2.a 는 같다 하지만 Test.a로 사용한다. 
ex) System.out.println();

static 변수 초기화
- static{ } 만들고 초기화 한다. static초기화 블록

ex)
	public static String company;
	private String modelName;
	
	static {
		company = "hyundai";
	}

	public Sonata() { //생성자.
	//     company = "이렇게 하지 않음";	
	}



static 메서드 생성
- 바로 사용가능한 변수와 상수만 사용가능(static 변수,상수 , 객체생성후 멤버변수, 메서드)
- 지역변수는 객체를 생성하고 객체명으로 접근해야 쓸수 있다.
- 		public static void me1() {
	//	System.out.println(a);	// a는 객체가 없으면 사용할 수 없어서 static메서드로 바로 사용불가
		Test t1 = new Test();
		t1.m2();
		System.out.println(t1.a); 	// 객체를 생성후 객체명으로 호출한다.
		System.out.println(Test.b);
	}

static 메서드 호출 
- Test.me1();

static 변수가 있을 때 getters,setters
ex) public class Sonata{
	public static String company;

	public static String getCompany() {
		return company;
	}

	public static void setCompany(String company) {
		Sonata.company = company;
     }
 
20.11.03)014------------------------------------------------------------------------------------------

Array[배열]

배열 생성
1. 자료형[] 변수명 = new 자료형[배열의 크기];
2. 자료형[] 배열명 = {값1,값2,값3....};
3. type[ ] arr = new type[] {val1, val2, val3....};
 ex) 
	Dog[] d = new Dog[3];
	Dog[] d2= {new Dog(), new Dog(), new Dog()};
	Dog[] d3= new Dog[] {new Dog(), new Dog(), new Dog()};
 ex2)
	Dog a = new Dog();
	Dog b = new Dog();
	Dog c = new Dog();
	Dog[] d2 = { a, b, c};
	Dog[] d3 = new Dog[] { a, b, c};
	
배열의 크기를 확인하는 속성
 - 배열명.length;
ex)
		int[] arrInt = new int[4];	//[ ] 1차원 배열 , [ ][ ] 2차원 배열, [ ] [ ] [ ] 3차원 배열 ...
		System.out.println(arrInt.length);
// length는 배열의 속성으로 반복문을 돌릴 때, 직접적인 배열의 크기 대신 사용
// arrInt.length로 길이를 구한다(반복문 횟수)
		int size = dogs.length;
		System.out.println(size); == System.out.println(dogs.length);
참조변수....
// Test class의 me12()에서 파라미터로 넘어온 배열 데이터의 크기 출력
		System.out.println(dogs.length);
ex1)
		 t1.me12(new Dog[5]);
ex2)
		Dog[] arrDog = new Dog[3];
		t1.me12(arrDog);
//자료형이 Dog인 1차원 배열 arrDog를 생성(두번째 방법)
// 배열의 크기는 2, 배열의 크기 출력
ex1)
		public void me21() {
		Dog[] arrDog = {new Dog(), new Dog() };
ex2)
		Dog a = new Dog();
		Dog b = new Dog();
		Dog[] arrDog2 = {a,b};
		
		System.out.println(arrDog.length);
		}

 배열의 각 요소값에 접근하는 방법
배열명[요소의 인덱스값] = 자료형에 맞는 자료;

index는 0~ length-1까지 (length개)
가장 큰 index = 배열명.length-1
	 //dogs의 가장 큰 인덱스 요소값을 null로 설정
	dogs[dogs.length-1]= null;

//index 요소 값의 출력
	//다차원 배열일 때
		int [][] arr2Int = {		// [][]2차원배열
			{1, 3, 5, 7},
			{0, 2, 3, 6}
		};
		int[] arr0 = arr2Int[0];	// type[] arr = [] / 하나를 풀면 []는 =의 우측으로
		int arr01= arr0[1]; 		// arr0[1] == arr2Int[0][1]

		int arr0arr1 = arr2Int[0][1];	// type a = arr[][] / 여러개를 한번에 풀 수 있다
					// arr01 == arr0arr1
				
배열을 사용하는 이유
1. 반복문 사용을 위해
2. 여러개의 데이터를 반환하기 위해

◇ 배열 크기 확인하는 속성
arr.length

◇ 배열의 각 요소값에 접근하는 방법
type[] arr = new type[length];		//[ ] 안에 크기(정수)를 지정.
type[] arr = {val1, val2, val3, val4...};
type[] arr = new type[] {val1, val2, val3, val4...};

ex) arr[0] --1차원 배열의 0번 인덱스 값, 1번째 값
   arr[0][1] -- 2차원 배열 0번 인덱스의 1차원 배열의 1번 인덱스값
			int [][] arr2Int = {
					{1, 3, 5, 7},  --> arr2Int[0] -> int[ ] arr0 = {1, 3, 5, 7};
					{0, 2, 3, 6}  --> arr2Int[1] -> int[ ] arr1 = {0, 2, 3, 6};
					};
				int[ ] arr0 = arr2Int[0];
				int arr01= arr0[1];
				int arr0arr1 = arr2Int[0][1];
				//arr01 == arr0arr1
◇ 배열의 각 요소값 변경
arr[index]= typeValru;
ex)	Dog[] dogs = new dogs[] { a, b, c...;};
	 dogs[index].setName = typeValru;
	
◇ 배열의 모든 요속값에 접근하는 방법
ex)	Dog[] dogs = new dog[] { a, b, c...;};
	for(int i=0; i < length; i++){
		arr[ i ]; // dogs[ i ];  
	}

◇ 참조자료형의 배열의 경우, 요소값의 특정 자원을 호출하는 방법
ex)	Dog[] dogs = new dog[] { a, b, c...;};
	dogs[index].getName;

◇ 첫 번째 방법으로 배열 생성 후 반복문을 이용하여 요소값을 변경하는 방법

◇ 다차원 배열...
n차원 배열 안에는 n-1차원의 배열이 들어있다.
ex) int[][] arr = {
	{1,2,3,4},
	{2,3,4,5},
	{6,7,8,9}
};
20.11.4)015----------------------------------------------------------------------------------
 배열TEST.txt
		for(int i=0; i<arr.length;i++) {
			System.out.println(arr[i]);

[I@36aa7bc2
[I@76ccd017
[I@182decdb
[I@26f0a63f
[I@4361bd48
===================> [ I @ 숫자 로 시작한다. 배열의 요소 초기값(주소)


◇다차원 배열

 2차원 배열 (불가변일 때)
2차원 배열 안에는 1차원 배열이 들어 있다.
***(n차원 배열안에는 n-1차원 배열이 들어 있다)
ex)
	Dog[][] arr = new Dog[10][2];

arr은 2차 배열이고, 1차배열을 10개 가지고 있다	[10개 = (00) (00) (00) (00) (00) (00) (00) (00) (00) (00) ]
(arr.length ==10)

arr[i]는 1차 배열이고, 배열의 크기는 2이다.	[2개 = 0 0]
(arr[i].length ==2)
i= 2차 배열의 크기만큼, 1차 배열의 갯수만큼 (0=i<arr.length)

arr[i][j]는 arr[i]의 요소값(arr의 최종 요소값)이다.	값 = 0
j=1차 배열의 크기만큼(0=i<arr[i].length)


◇가변형 배열
int[][] arr = new int[3][];	//다차원 배열에서 n차원 배열의 크기를 지정해 줘야 한다. (3이 없으면 에러)
가변형 n-1차원 배열 요솟값의 입력은 변수.length의 값이 없으면 안된다.

=== String class

◇ String()

//명시적 객체생성
(힙메모리영역에 생성)
		String msg = new String("hello");
//암시적 객체 생성법(리터럴)
(메소드 메모리 영역에 생성)
		String msg2="hello";

ex)  메소드 메모리의 값은 최대한 공유하려 한다.
 		String msg1 = new String("a");
		String msg2 = new String("a");
		String msg3 = "a";
		String msg4 = "a";
		
		System.out.println(msg1==msg2); //false
		System.out.println(msg1==msg3); //false
		System.out.println(msg3==msg4); //true

ex) 데이터 값만 비교 equals
		System.out.println(msg1.equals(msg2)); // true
		System.out.println(msg1.equals(msg3)); //true

◇ to String()
- String형으로 변경 해준다

◇ StringBuffer()
String클래스는 불변적 성격을 갖고있어서 
변수에 새로운 값을 대입해도 이전의 값이 바로 삭제되지 않고 메모리에 남아있다.
(시간이 지나면 가비지컬렉터가 삭제)
문자열이 계속 누적되는 경우 메모리 부족, 속도저하의 문제를 발생시킬 수 있다.
이럴 때 StringBuffer()를 사용한다.

ex)
- String msg = "hello";
		msg = "good";		
		msg ="";
		msg +="안녕하세요";
		msg +="저는 홍길동입니다";
		msg +="저는 어디 살고있어요";
		msg +=... 누적....
		
- StringBuffer sb = new StringBuffer();	
		sb.append(" 안녕하세요");
		sb.append(" 저는 홍길동입니다");
		sb.append(" 저는 어디 살고있어요");
		msg = sb.toString(); 		// sb를 String형으로 변경해 준다.
 syso(msg)--> " 안녕하세요 저는 홍길동입니다 저는 어디 살고있어요";	

◇중요◇ equals()
 참조자료형의 비교연산
 동등성을 비교 (객체의 구성요소 중 하나를 비교)
(기본자료형의 비교연산은 ==을 사용)

 동일성 비교: (데이터와 저장위치) Vs 동등성 비교: (데이터만 비교)
(기본료형)== Vs (참조자료형) equals( )

20.11.05)016---------------------------------------------------------------------------------------

 ◇◇ 문자열 API ◇◇

.length 
문자열의 길이를 int형 반환
문자열의 크기를 알고 싶을 때 사용
	public void me5() {
		String msg = "hello";
		System.out.println(msg.length());
	}

.charAt 
특정 index의 문자를 char형 반환
문자열의 특정 인덱스에 있는 문자를 알고 싶을 때
	public void me6() {
		String msg = "hello";
		System.out.println(msg.charAt(msg.length() - 1));
		for (int i = 0; i < msg.length(); i++) {
			System.out.println(msg.charAt(i));
		}
	}


.contains 
문자열에서 찾고자 하는 문자열의 유무를 boolean형 반환
문자열에서 특정 문자열이 있는지 알고 싶을 때

.indexOf 
문자열에서 찾고자 하는 문자열의 첫 index를 int형 반환
해당 문자나 문자열이 없으면 -1을 반환
.lastIndexOf
문자열 끝에서 부터 찾는다
	public void me7(String msg) {
		boolean result = msg.contains("he");
		int idx = msg.indexOf('k');
		System.out.println(result); // true
		System.out.println(idx); // -1

		idx = msg.indexOf('l'); // 첫 l의 idx
		System.out.println(idx);

		int lastIdx = msg.lastIndexOf('l');
		System.out.println(lastIdx);

		idx = msg.indexOf('l');
		System.out.println(idx + 1); // 두번째 l의 idx

		idx = msg.indexOf('l');
		System.out.println(idx + 1); // 세번째 l의 idx

	}

.endswith() 
문자열이 특정 문자열로 끝나는지 boolean형 반환
확장자명을 확인할 때 사용
	public void me8() {

		String msg1 = "abcd.jpg";
		String msg2 = "defg.txt";
		boolean result1 = msg1.endsWith("jpg");
		boolean result2 = msg2.endsWith("txt");
		System.out.println(msg1);
		System.out.println(msg2);

	}

.startswith() 
문자열이 특정 문자열로 시작하는지 boolean형 반환
	public void me9() {
		
		String msg = "hello";

		boolean result = msg.startsWith("h");
		System.out.println(result);
	}	

.equals() 
문자열과 문자열의 동등성을 비교해 boolean형 반환
문자열과 문자열의 데이터 값이 같은지 확인할 때 사용
.equalsIgnoreCase() 
문자열과 문자열의 대소문자와 상관없이 동등성을 비교해 boolean형 반환
	public void me10() {
		// 문자열끼리 데이터 값이 같은지 여부 확인
		// equals(), equalsIgnoerCase
		String msg1 = "hello";
		String msg2 = new String("hello");
		String msg3 = "hello";

		System.out.println(msg1.equals(msg2));
		System.out.println(msg1.equals(msg3));
		System.out.println(msg1.equalsIgnoreCase(msg3));
	}

.trim() 
문자열 좌우의 빈 공백을 제거
다시 문자열에 저장
	public void me11() {
		// 문자열의 좌우 공백제거
		// .trim()
		String msg = "      he       llo       ";
		System.out.println(msg);
		System.out.println(msg.trim());
		msg = msg.trim();
		System.out.println(msg);

	}

.substring() 
문자열의 특정 인덱스부터 특정 인덱스까지(지정할 때) String형 반환
"hello world"에서 "hello "를 잘라내고 "world"만 남게 하고싶을 때

	public void me12() {
		
		String msg = " hello world";
		msg = msg.trim();
		int idxS = msg.indexOf("w");
		String sub = msg.substring(idxS);
		System.out.println(sub);

	// sub = "lo wor";

		idxS = msg.indexOf("l");
		idxS = idxS + 1;
		int idxE = msg.indexOf("r");
		idxE = idxE + 1;
		sub = msg.substring(idxS, idxS);
		System.out.println(sub);

	}

.split() 
문자열을 특정 문자열로 분리하여 String[]형 반환
특정기준문자(delim)를 이용하여 서로다른 의미를 갖고 있는 문자열(=token)을 분할
 		String msg = "teacheryo#1234##vip#1000#g#";	// ~##~ 중간은 인정 ~~#마지막은 no
		String[] arr = msg.split("#");			// delim은 "#"
		
		int token = arr.length;			// 토큰의 개수(배열의 갯수)
		System.out.println(token);			// 6
		for(int i=0;i<arr.length;i++) {
			System.out.println(arr[i]);		//모든  토큰 출력
		}

StringTokenizer()
StringTokenizer 변수 = new SrtringTokenizer(문자열, delim);
﻿특정기준문자(delim)를 이용하여 서로다른 의미를 갖고 있는 문자열(=token)을 분할
.countTokens() 
StringTokenizer의 토큰의 갯수를 int형 반환
.hasMoreTokens() 
StringTokenizer의 토큰의 갯수 조건을  bolean형으로 반환(while문 조건식으로 사용)
.nextToken() 
StringTokenizer의 다음 토큰 String형 반환
 (split() + StringBuffuer 와 비슷)  
	
	public void me13() {
		
		String msg = "String#Tokenizer#new#st.#";
		StringTokenizer st = new StringTokenizer(msg, "#");
		String[] arr = new String[st.countTokens()];
		int i = 0;
		while (st.hasMoreTokens()) {
			arr[i] = st.nextToken();
		}

		for (int j = 0; j < arr.length; j++) {
			System.out.println(arr[j]);
		}

	}

.toUpperCase(); 
문자열을 대문자로 변경
.toLowerCase(); 
문자열을 소문자로 변경
	public void me15() {

		String msg1 = "hello";
		String msg2 = "Hello";
		String msg3 = "HELLO";

		// 대소문자로 변경
		String s1 = msg1.toUpperCase();
		System.out.println(s1);
		String s2 = msg2.toLowerCase();
		System.out.println(s2);

	}

args 
(type...변수명)
가변인자(variable argument)
파라미터(매개변수)를 배열이 아니어도 ,로 구분하여 여러개 으로 입력 받을 수 있다.
배열을 선언하고 입력한 것처럼, .length , arr[i]등으로 사용 할 수 있다.

	public void me3(int a, int b, int...arr) {
		System.out.println(a);
		System.out.println(b);
		
		for(int i=0; i<arr.length;i++) {
			System.out.println(arr[i]);
			}
		}

		public void me2(){
		me3(1,2,3,4,5,6,7,8, 20,44,...); // 가능
	}


String.format()
 문자열과 숫자의 표현
 String format(문자열, 값) args 가변인자
 %d %s %f %t %c %x %%
 표현자릿수 지정: %자릿수d
 좌정렬: %-자릿수d
 소수자릿수: %총자릿수(소수점 포함, 오른쪽 정렬).소수점이하자리수d
 소수점 이하 자릿수는 반올림
 ,의 표현(ex 1,000원): %,자릿수d
 자릿수 지정 후 빈공간을 0으로 채움: %0자릿수d

	public void me14() {
		
		String msg = "홍길동" + %d + " 살입니다.";
		String msg2 = "홍길동은 %d 살입니다.";
		System.out.println(String.format(msg2, 17));

		// 자릿수 공백포함 줄마추기
		String msg3 = "오늘은 2020년%2d월20일 입니다.";
		System.out.println(String.format(msg3, 3));
		String msg4 = "오늘은 2020년11월%-4d일 입니다.";
		System.out.println(String.format(msg4, 20));

		// 금액에 ,표기
		String msg5 = "내 전재산은 %d원입니다.";
		System.out.println(String.format(msg5, 1000));
		String msg6 = "내 전재산은 %,d원입니다.";
		System.out.println(String.format(msg6, 1000));
		String msg7 = "내 전재산은 %,15d원입니다.";
		System.out.println(String.format(msg7, 1000));

		// 자릿수의 공백을 0으로 채우기
		String msg8 = "내 등번호는 %2d입니다.";
		System.out.println(String.format(msg8, 8));
		String msg9 = "내 등번호는 %02d입니다.";
		System.out.println(String.format(msg9, 8));

		// 가변 매개변수
		String msg10 = "%d+%d = %d입니다.";
		System.out.println(String.format(msg10, 2, 3, 2+3));

		// 소수점의 자리수, %표현
		String msg11 = "%5.2f%%입니다.";
		System.out.println(String.format(msg11, 52.627));
		System.out.println(String.format(msg11, 52.627));

	}

201106)017-------------------------------------------------------------------------------------------


◇ 상속
---
프로젝트 내에 각 클래스의 메서드 상수 변수에 중복되는 코드가 있을 때 유지보수를 용이하게 하기위해 사용
부모클래스의 자원 변수 상수 메서드를 자식 클래스에서 임의로 사용할 수 있게 하는 기술
부모클래스의 필드와 메서드를 물려받게 된다
부모클래스를 지정or생성한다
상속의 표현은 자식클래스에서 extends 부모클래스명 으로 한다

부모클래스는 슈퍼클래스 기본클래스라고도 불리며 객체를 만들지 않지만 자료형으로는 사용가능 하다
자식클래스는 서브클래스 유도클래스라고도 불리며 상속을 표현한다

자바의 최상위 클래스는 오브젝트이며 자바는 단일 상속을 원칙으로 한다. 인터페이스는 예외로 다중상속을 지원한다
부모클래스의 변수명과 자식클래스의 변수명이 같을 경우 자식클래스의 변수를 우선 인식하기 때문에
부모클래스의 변수명을 지칭할 때는 super.변수명 으로 기술한다.
---

프로젝트 내에서 각 클래스 중(메서드or변수or상수)에 중복되는 코드가 있을 때
유지보수를 용이하게 하기위해
부모클래스의 자원(변수/상수/메서드,생성자는 불포함)을
자식클래스에서 임의로 사용할 수 있게 하는 기술.
부모 클래스의 필드와 메서드를 물려받게 된다
부모클래스 지정(생성), 자식클래스에서 extneds(class A extends B {...})

ex)
BMW class, K7 class, SM5 class 등
모두 model, price, company 등의 field가 같을 때 사용자 생성자, get,set메서드가 계속 중복됨
중복되는 코드가 있다해도 같은 개념(상위개념, Car생성)만 상속적용
public class BMW extends Car{}

부모클래스
super class, 기본클래스
 디폴트생성자, 사용자 생성자, field, getters, setters 메서드(자식클래스의 중복코드)를 선언
 자식클래스에 상속의 표현을 한다. extends 부모클래스명.
 객체를 만들지 않는다( Car car1 = new Car() X ), 
 자료형으로는 사용가능 ( Car[] arrCar; O )

자식클래스
sub class, 유도클래스

상속의 표현 extends
class (자식)클래스명 extends (부모)클래스명{...}
사용자 생성자는 = Shift + Alt + s -> Constructors from Superclass...

자바의 최상위 부모클래스는 Object

자바는 단일 상속이 원칙
예외적으로 interface는 다중상속을 지원

super(): 부모 클래스의 생성자 호출==> 부모 객체
부모 클래스도 보이지 않지만 extends Object 가 존재
자식 클래스는 부모클래스로부터 간접적으로 Object의 클래스를 사용

부모클래스의 변수명과 자식클래스의 변수명이 같을 경우,
자식클래스의 변수가 우선인식
부모클래스의 변수를 가르키고 싶을 때는 super.변수명
(this.(자신의, 멤버변수지칭) 와 비슷하게 super. 는 부모클래스를 지칭한다)

===

◇ 다형성
---
객체를 생성하는 다양한 방법으로
슈퍼클래스타입 변수명 대입연산자 자식생성자로도 객체를 생성할 수 있다
다형성으로 만들어진 객체의 자료형은 슈퍼클래스타입으로 통일된다
타입의 통일로 여러타입의 객체, 자식 클래스의 객체들을 한번에 사용할 수 있다
---

객체를 생성하는 다양한 방법
 부모자료형 변수명 = new 자식생성자(); 	// 이게 가능함
 자식자료형 변수명 = new 자식생성자();	//원래 가능했음

*다형성으로 만들어진 객체의 자료형은 부모자료형으로 통일 된다
(Car[]로 선언, 묶어줄 수 있다)-> 상속을 하는 이유인가
ex)
		Sonata sonata1 =new Sonata();
		BMW bmw1 = new BMW();
	// 아래의 방법으로 생성(다형성으로)		
		Car sonata2 = new Sonata();
		Car bmw2 = new BMW();
		
		Car[] arrCar = {sonata1, bmw1, sonata2, bmw2};

상속
프로잭트 내 중복된 코드를 가진 메서드의 유지보수가 용이
슈퍼클래스의 자원을 서브클래스가 사용
서브클래스에서 상속을 표현(extends superClassName)

superClass
부모클래스, 기본클래스
객체 생성하지 않음
type으로 사용

subClass
자식클래스, 유도클래스
상속을 표현

Object
최상위 클래스
단일속성원칙

Interface
다중상속지원

superclass와 subClass의 변수명이 같을 때 subclass의 변수를 우선인식
superclass의 변수를 지칭 할 때 super.변수명

다형성 
객체를 생성하는 다양한 방법
슈퍼클래스타입 변수명 = new 서브생성자(); 
*다형성으로 만들어진 객체의 타입은 슈퍼클래스타입


◇ 메서드 오버라이딩
상속 관계가 성립하는 클래스에서
부모클래스가 갖고 있는 메서드(run())의 내용을
자식클래스에서 재정의(수정/삭제/추가)하는 것

 (부모클래스의 메서드와 같은 이름의 메서드를 
자식클래스에서 오버라이드 메서드 메뉴를 이용해 생성, 수정한다
이 메서드를 호출 하더라도 부모클래스의 메서드는 작동하지 않고
오버라이딩된 자식클래스의 메서드가 호출된다.
다형성을 이용해 생성한 타입이 부모클래스타입인 객체만 적용)
 =
다형성으로 생성된 객체(sonata2)의 경우, 자료형이 부모자료형(Car)이라도 (부모의 run이 실행되지 않음)
그 객체가 호출한 메서드(run())는 오버라이딩된 메서드( 자식 생성자에서 재정의한 run())다

오버로딩과 오버라이딩에 대해서 설명
- 오버로딩은 같은 클래스에서 이름이 같은 메서드가 파라미터 자료형에 따라 인정되는 문법
- 오버라이딩은 상속관계가 성립하는 부모클래스와 자식클래스에서 자식클래스가 부모클래스의
메서드를 재정의하는 것을 의미.
 -- 다형성으로 생성된 객체의 경우에는 자료형이 부모자료형이라도 
그 객체가 호출한  메서드는 오버라이딩된 메서드다

다형성으로 객체를 만들면 생기는 문제점
 자식클래스가 갖고 있는 고유자원에 접근할 수 없다.
- 이유는 자료형이 부모자료형이기 때문
- 해결방법: instanceof, getclass() 를 사용하여 접근할 수 있다.
ex)
		Sonata s =null;
		if(sonata2 instanceof Sonata) {
			s=(Sonata)sonata2;
			s.only();
		}
		if(sonata2 instanceof Car) {
			s=(Sonata)sonata2;
			s.only();
		}
		//
		
		Sonata ss=null;
		if(sonata2.getClass()== Sonata.class) {
			ss=(Sonata)sonata2;
			ss.only();
		}









[[연습문제]]
GG / 프로젝트 
영웅1, 무기3종류 각1개씩 총3개
Bow Sword Gun
파워 1, 5, 10
그중 하나를 이용해 몬스터를 공격할수 있음
영웅은 가지고 있는 무기 중에서 공격용 무기를 변경할 수 있다
무기에 공격할수 있는기능
 필드 공격력
 공격 할 수 있는 메서드


내일 
반드시 오버라이딩, 절대로 오버라이딩, 객체생성불가능하게 하는 방법
추상화. 콘솔창 데이터 입력
스프링프레임워크

[[연습문제]] 11.05
	// "    동해물과 백두산이 up 마르고 닳도록 하나님이 UP 보우하사 우리 나라만세!    "
	// 좌우 공백 제거, 
	// 마르고 닳도록 만 str1;
	// 우리 나라만세 까지 str2;
	// up과 UP을 strUp1,2로 저장하고 동등성 비교

 		ArrayList<String> list = new ArrayList();
		// list.size(); 

		StringTokenizer st = new StringTokenizer(msg, "#");
		String[] arr = new String[st.countTokens()];
		int i = 0;
		while (st.hasMoreTokens()) {
			arr[i++] = st.nextToken();
		}

 String APi
 variabla args

[[연습문제]] 11.04
	// String 변수로 이름을 선언하고 #으로 구분한다
	// String 배열에 split("#")으로 나눈 문자열 선언과 대입.
	// Dog 배열을 선언(String배열의 크기(길이)만큼 생성), 
	// Dog 배열의 각 요소의 name(dog 멤버변수)에 String배열의 각 요소를 대입
	// (Dog 배열을 반환하여 각 요소출력 메서드)각 요소의 name을 출력

	// 최종 값은 5 ~9 다음 0~9 0~9 순환되면서 배열에 들어감
	// int형 3차원 arr3은 3X1X4크기

	// arr3의 마지막 index의 요솟값의 1번째 요솟값 출력
		
	// 최종 값은 5 ~9 다음 0~9 0~9 순환되면서 배열에 들어감
	// int형 2차원 배열 arr4는 5x3크기
	
	// arr4의 [2][1]의 요솟값을 100으로 수정 (가로~~세로~)

	// arr4의 3번째 요소값의 최종 요솟값을 구하라.

	// StringBuffer 사용 
	// "태산이 높다하되 하늘아래 뫼이거늘 오르고 또 오르면 못 오를릴 없건마는 
	// 사람이 제 아니 오르고 뫼만 높다 하더라

	// equals로 참조자료형 비교
	// String형 a1, a2 "a" 선언 
	//참조자료형 String a3,a4 선언 eqauls로 비교 



정보처리기사 실기 알고리즘

https://edu.goorm.io/search?subject=java%20%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9&page=1&sort=newest
실습코딩 인터넷강좌

=== 에러 메세지
//%-d String.format()에러 확인
자릿수를 지정하지않고 좌정렬했을 때

ArrayIndexOutOfBoundsException
선언한 index의 값을 벗어남 (MAX_index= length-1과 같음)
NullPointerException 
객체가 만들어 지지 않았는데 자원에 접근하려 할 때 에러
*자원 = 변수, 상수, 메서드
ArithmeticException
수치를 0으로 나눴을 때 에러

=== 스위치 연산
두 값을 실행 할 때 마다 번갈아 가며 값이 나온다.
초기값이 0 or  1, true or false 이어야 한다
(boolean a)	a = !a;
(int a)		a = 1-a;	







