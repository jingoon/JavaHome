java 개발환경 설치. + 학습

01--------------------------------------------------------------------------------------------

1. jdk 설치
-> 자바 개발환경 설정, 설치 
https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html
*모달창: 팝업창처럼 새로운창, 메인창은 비활성화됨, 모달창에 동의해야 다시 안생김.
계정 : park~gmail / D용 ~@
환경변수 - eclipse로 작업하기 때문에 안해도됨
cmd : java -version 확인

2. ide(eclipse 다운)  Enterprise (java는 SE-무료, 이클립스 Enterprise에서 어느정도 지원))
https://www.eclipse.org/

3. 자바 프로젝트 저장 공간
 - workspace_java

4. eclipse의 구조
 window - show view , new Window(창 다 닫혔을 때)
-> Package Explorer , Console
 window - Open Perspective - java Perspective

[ctrl + n]
 Java Project, JavaSE-1.8
HelloWorld(C:\workspace_java 에 디렉토리생성됨)
프로젝트 첫 글자 대문자, 띄어쓰기하지 않음, 띄어쓰는 단어의 첫 글자 대문자

 src - Java Package - 
Package(디렉토리) -도메인이름 뒤에서부터 소문자(com.naver / kr.co.ezen)

class
첫 글자 대문자, 띄어쓰기하지 않음, 띄어쓰는 단어의 첫 글자 대문자
main() 메서드 생성 -> main 적은 후 [ctrl + space]

console
[sysout] 적은 후  [ctrl + space]
println("hello world");
println(11);
println("A");

5. 콘솔에 "hello world" 출력
 console
[sysout] 적은 후  [ctrl + space]
println("hello world");
println(11);
println("A");

6. 변수(데이터) ,32가지? 암기!
 a = b; 
= 는 대입 연산자 -> b의 값을 a에 대입(같다 아님)(o), a를 b에 대입(x)
a -> 변수명(그릇)
b -> 값 or 변수 (b의 값이 사라지지 않음)

--
프로젝트(폴더, main한개, 첫대문자) -src- 패키지(폴더,소문자 도메인) - 클래스(첫 대문자)

github에 적용
githubstudy - javastudy 에 파일 넣기
cmd에서javastudy이동 파일 add, commit, push 
깃허브 로그인

02---------------------------------------------------------------------------------------

 변수!!
-----
메서드 생성
메서드 호출(사용)
------
main,class 스코프 - {_더블클릭
 } (파란선택영역)
-----

String name = "문자열";	 // 중복되는 문자열 변수선언
System.out.println(name);	//""없이 입력

변수 선언 공식
**자료형 변수명 = 자료형에 맞는 값;
--
// 변수 선언 공식
// 자료형 변수명 = 자료형에맞는값;
// 값에맞는자료형 변수명 = 값;
--

변수 차이 예)
String jin = "11";		// String 문자열 "11" 로 선언
int jin3 = 11;		// int 정수 11로 선언

System.out.println(jin+jin );		//출력 1111
System.out.println(jin3+jin3);		//출력 22


자료형(type)의 종류 (크게 두가지)
1. 기본자료형(primitive) 8가지.
- boolean : true, false
 (boolean a = true; or boolean a = false;)  

- char : 한 글자
 (char = '한';)

- 정수형(값의 범위가 중요)
byte	(1byte=8bit)	-128~127	
short	
int	(4byte)		-21억~+21억 	42억(2의 32승)
long	(8byte)
*int (+-)21억, 정수형의 기본자료형
*long형에 맞는 값(약 21억 이상)은 숫자 뒤에 L/l을 써줘야 한다.

- 실수형(정밀도가 중요)
float : 값 뒤에 F/f를 써줘야 한다.
double : 실수형의 기본 자료형
BigDecimal


-> 참조자료형(referece) :  기본자료형이 아닌 자료형
MainEx me = new MainEx();
String msg = new string("hello");
String : "문자열"


변수선언은 자료형 변수명 = 자료형에 맞는 값; 이다

자료형은 기본자료형과 참조자료형으로 나뉜다
참조자료형은 기본자료형을 제외한 자료형이다
기본자료형은 논리,문자,정수,실수 8가지 이다
논리 자료형 boolean 은 true, false만을 값으로 대입할 수 있다
문자 자료형 char 은 문자 '한' 글자만 ''안에 적는다
정수 자료형은 값의 범위에 따라 4가지로 나뉜다
byte 는 -128~127까지의 범위를 갖는다 1byte(=8bit) 2^16
short 는 -32768~32767까지의 범위를 갖는다 2byte 2^32
int 는 정수형의 기본자료형으로 약 -21억~21억의 범위를 갖는다
long 는 int형의 범위를 초과하는 약 -22억 이하 +22억 이상의 값일 때 사용한다
lomg 는 마지막에 l/L을 적는다
실수자료형은 정밀도를 기준으로 나눈다
float보다 double이 더 정밀하다
float는 마지막에 f/F를 적는다
double는 실수형의 기본자료형이다

03 -------------------------------------------------------------------------------------------

참조자료형(reference type)의 변수 선언

자료형 변수명(reference) = new 자료형();   ->생성자(자료형();)
ex) String msg = new String("hello");
 
--
Dog class : 참조자료형 ,Dog dog = new Dog(); ->creat class 호출.
String class : 참조자료형
Command 인터페이스 : 참조자료형
int[ ] : 참조자료형
--
아스키코드(검색해보기)
--
기본자료형 =
수치형 자료형 : boolean 제외한 기본자료형
+ 
비수치형 자료형 : boolean
--
지역(local) 변수의 스코프: 선언 이후, 생성자 or 메서드의 스코프({}영역) 끝까지
지역변수: 메서드나 생성자, 제어문(if, for) 안에서 선언된 변수 (보안에 좋다)
	클래스의 필드 외에서 선언된 변수
	선언된 이후부터 해당 중괄호의 종료 표기까지( } )
멤버변수: 클래스 필드에 선언된 변수 , - 객채의 구성 요소

클레스 이름과 생성자(참조자료형) 이름은 같아야 한다.

일반적으로 지역변수는 선언과 동시에 초기화 - 자료형 변수명 = 자료형의 맞는값;
	  멤버변수는 선언만 한다 - 자료형 변수명; 
String master;
int i;
double d;

초기화: 변수 선언과 동시에 값을 대입하는 것.
int i = 0;
String master = "마스터";

=== 생성자? 메서드? 클래스필드?
package co.naver;
public class Cat {				
	//member 변수(클레스 필드에 선언된 변수)
	String name = "happy"; 
	int age;
	String addess;

	public Cat() {			// 생성자
		System.out.println(name);
		int b = 33;
		System.out.println(b);
		me1(); // 멤버들끼리는 순서가 중요하지 않다 
	}
	public void me1() {			//반환값이 없다, 메서드
		System.out.println(name);
	}
}
==
Object(모든 자료형을 포함) 
Object c;

생성자호출 - Test test = new Test();

생성자 public 클레스명과동일(){ }

자료형의 디폴트값
boolean는 false(0)
char는 빈칸
정수형은 0 
실수형은 0.0
참조자료형 디폴트값은 null(값이 없음)

1. 지역변수의 개념
 - 메서드나 생성자 안에서 선언된 변수
 - 선언위치 부터 해당 변수 영역끝( } )까지 사용
2. 지역변수의 스코프에 대해서 깊게 학습
 - 선언 위치 ~ 해당 변수가 선언된 곳의 } 까지
3. 초기화
 - 변수를 선언할 때 값을 같이 입력해주는 것
 - 초기화 예제) int a =3;
 - 초기화를 하지 않은 예제) int = b;
4. 멤버변수의 개념
 - 클래스의 멤버로 선언된 변수
 - 생성자나 메서드의 밖에서 선언된 변수
 - 클래스 전체에서 사용
5. 멤버변수의 일반적인 사용
 -초기화하지 않고 선언만 함
 - int a;
 - Dog d;
6. 멤버변수의 디폴트값
 - boolean - false
 - char - 공백
 - 정수형 및 실수형 - 0
 - 참조자료형 - null
7. (변수)대입: 반드시 변수가 선언된 후에만 가능
 *변수 선언과 동시에 값을 넣으면 초기화, 선언이후에 값을 넣으면 대입.
 - 변수명 = 자료형에 맞는 값;
 - 예 a = 10;

 int a =44; <<초기화
 a = 44; << 대입

메서드(함수) ! 

void =반환값이 없을 때
반환형 : 반환되는 데이터(값)의 자료형

04----------------------------------------------------------------------------------

static(특별함?)
literal: 상수, 대입의 대상이 될수 없다.

메모리 영역 할당 
/method//stack//heap        /
method : 
stack : 힙 메모리의 주소 값(int형) // 인트 자료형 변수 선언의 대입되는 값
heap : 객체(참조자료형의 값) // new MerhodTest();
Dog d = c; (이렇게 주소값만 넘겨줄 수도 있다)

생성자 
-> public className(){ } 디폴트 생성자 // 객체를 생성

메서드 
-> publric void Name(){ } 무반환 무파람 메서드 // 객체의 기능
-> 객체의 기능, 행위, 능력을 의미(java에서는 함수), 중복 코드를 묶어주는 역할

ex)
public class MethodTest {
public MethodTest() {} --> 객체 생성, 생성자
public void sleep(){} --> 객체 선언, 메소드
                          --> 무반환(void) 무파람(괄호가비어있음)
public (접근제한자)
-> 프로젝트 전체에서 sleep메서드가 호출될 수 있음을 의미

void (반환형: 반환되는 데이터의 자료형) 
-> 반환되는 데이터가 없다는 의미

sleep (메서드의 이름) 
-> 메서드 호출 시, 이름을 적음으로 메서드 본문 코드를 실행하게함

( ) (파라미터, 매개변수 선언하는 곳)
-> 변수를 선언하듯 작성. 파라미터가 두개 이상일 때는 ,를 구분자로 구분

{} (메서드의 본문)
-> 메서드 호출 때 실행하고 싶은 코드 작성
}


메서드 선언공식
접근제한자 반환형 메서드명(파라미터자료형 파라미터변수) { 
	메서드 호출 시 실행 코드
}
ex) 메서드 선언
public MethodTest(){
	 public void callName(String name) { 
	 System.out.println(name);
	 }
}
ex) 메인 클레스에서 호출
 MethodTest m1 = new MethoTest();
 m1.cllName("홍길동");


메서드의 종류

1. 무반환(void) 무파람 : void, 파라미터가 ( )
 //메서드 생성 ex)
public void callName(){
     System.out.println("무변환 무파람");
}

2. 메서드 호출 
-> 메서드를 사용하는 것을 의미
-> 메서드명을 적고 소괄호, 그 소괄호 안에 파라미터의 자료형에 맞는 값을 입력

 2.1 같은 class 호출 : 메서드명() 
-> ex) callName();		// 메서드 호출

 2.2 다른 class 호출 : 객체생성 후 객체명.메서드명();
-> ex) MethodTest mt = new MethodTest();  //객체 생성
         mt.callName();			// 메서드 호출

3. 무반환 유파람(파라미터 있음)

3.1 메서드 생성
 class [ MethodTest ]에서 printScore(String name) 메서드 생성 
-> 메서드 파라미터에 자료형(String)과 변수명(name)을 작성

// 메서드 생성 ex)
public void printScore(String name, int score){
     System.out.println(name + " " + score + "점")
}

3.2 메서드 호출
 객체 생성 후
mt.printScore(자료형에 맞는 값)	//메서드 호출 (자료형에 맞는값)

// 메서드 호출 ex)
1) 같은 class
﻿printScore("홍길동", 100);

2) 다른 class
MethodTest mt = new MethodTest(); //객체 생성
mt.﻿printScore("홍길동", 100); // 메서드 호출﻿

05--------------------------------------------------------------------------------------------

개념 참고 http://tcpschool.com/java/intro

클래스 = 설계도
객체(변수) = 실체
변수 = 구성요소(핸들, 이름), 
메서드 = 기능,능력(가속하기)
생성자(constructor) = 객체 선언, 객체의 맴버변수의 초기화, 리턴값 없음(void 안쓴다)
지역변수 = 외부에서 접근불가, 보안에 강하다
멤버변수(field) = 외부에서 접근가능
매개변수(parameter) = 메서드에 넘겨줄 값, ()안에 기술
값을 반환 return (반환자료형에 맞는 값);

3. 유반환 무파람
3.1 참조변수 반환
public Test12 getTest12() {			//Test12(반환자료형)
		return new Test12();
	}

MethodTest3 mt7 = new MethodTest3();	//클래스이름 객체변수명 = new 클래스이름(생성자) -->인스턴스(객체)생성
		Test12 re4 = mt7.getTest12();	// 반환자료형 변수명 = 객체변수명.메서드명

3.2 기본자료형 반환
public int getTest13() {
		return 99;
	}

MethodTest3 mt8 = new MethodTest3();	//인스턴스(객체) 생성, 클래스가 메모리에 생성
		int re5 = mt8.getTest13();


06--------------------------------------------------------------------------------------------------------------------
- TEST -

1. 자료형의 종류를 기술하시오.
자료형은 기본자료형과 참조자료형으로 나뉜다
참조자료형은 기본자료형을 제외한 자료형이다
기본자료형은 8가지로 boolean, char, byte, short, int, long, float, double이 있다

2. 정수형 변수 a에 자료형에 맞는 값 중 하나를 적으시오.
-33

3. long 형에 맞는 값 중 하나를 적으시오.
2400000000L

4. float 형에 맞는 값을 하나 적으시오.
3.14f

5. boolean  형에 맞는 값 두 개르를 적으시오.
true
false

6. char 형에 맞는 값을 하나 적으시오.
'a'

7. Dog형에 맞는 값을 하나 적으시오.
new Dog()

8. String 형에 맞는 값을 하나 적으시오.
"홍길동"

9. Cat형에 맞는 값을 하나 적으시오.
new Cat()

10. Pig형에 맞는 값을 하나 적으시오.
new Pig()

11. Car형에 맞는 값을 하나 적으시오.
new Car()

12. Apple형에 맞는 값을 하나 적으시오.
new Apple()

13. 클래스 Dosirak의 디폴터 생성자를 적으시오.
public Dosirak(){
}

14. 클래스 Gost의 디폴터 생성자를 적으시오.
public Gost(){
}

15. 클래스 Member의 디폴터 생성자를 적으시오.
public Member(){
}

16. 무반환 무파람 메서드 showMetheMoney( )를 작성하고 호출 코드도 작성하시오.
     - 단, 실행 내용은 "500원" 출력
     - 단, showMetheMoney( )는 Bank클래스의 메서드이다.

public Bank(){	
}
public void showMetheMoney(){
	System.out.println("500원");
}

main에서 호출
Bank bank = new Bank();
bank.showMetheMoney();

17. 무반환 유파람 메서드 setName( )를 작성하고 호출 코드도 작성하시오.
    - 단, 실행 내용은 this.name = name;		
    - 단, setName( )는 Member클래스의 메서드이다.

private String name;		// 필드에 선언
public Member(){
	 
}
public void setName(String name){
	this.name = name;		//this는 객체 자기자신을 의미
}				//지역변수와 멤버변수가 같을 때 지역변수가 우선(그래서 this.을 사용)

main에서 호출
Member member = new Member();
member.setName("홍길동");

18. 유반환 무파람 메서드 getBoard( )를 작성하고 호출 코드도 작성하시오.
    - 단, 실행 내용은 Board클래스의 객체를 반환한다.
    - 단, getBoard( )는 Board클래스의 메서드이다.

public Board(){
}

public Board getBoard(){
	return new Board();
}

main에서 호출
Board board = new Board();
Board b1 = board.getBoard();

- TEST End -


4. 유반환 유파람

private String carName; 
field(멤버변수)는 private로 선언 외부에서 접근 불가
외부에서 접근하기 위해 get~, set~ 메서드 필요
get, set 메서드는 이클립스에서 마우스 우클릭(source - Generate Getters and Setters) 에서 해당 필드 체크
혹은 직접입력
public String getCarName() {
		return carName;
	}

public void setCarName(String carName) {
		this.carName = carName;
	}

파라미터 입력, 리턴 (기능수행) 반환

파라미터가 있음으로 동적실행가능(입력값이 변함)

// 메서드 기본 4유형 
	
	// 1. void(return 값 없음), 매개변수 없음
	public void me1() {
		
	}
	
	// 2. void(return 값 없음), 매개변수 있음
	public void me2(String name, int age) {
		
	}
	
	// 3. return(참조자료형) 있음, 매개변수 없음
	public Dog me3() {
		return new Dog();
	}
	
	// 4.return(정수형) 있음, 매개변수 있음
	public int me4(String name) {
		int size = name.length();
		return size;
	}

// 메서드 4유형 호출
		
	Dog hot = new Dog();
		
	// 1. void(return 값 없음), 매개변수 없음
	hot.me1();
		
	// 2. void(return 값 없음), 매개변수 있음
	hot.me2("핫도그", 2);
		
	// 3. return(참조자료형) 있음, 매개변수 없음
	Dog hotDog = hot.me3();
		
	// 4.return(정수형) 있음, 매개변수 있음
	int gotDog1 = hot.me4("갓도그");
	int gotDog2 = hot.me4(new String("갓도그"));
	

07-------------------------------------------------------------------------------

5. 메서드 오버로링

* 파라미터의 개수or자료형or순서가 다르면 성립*

5.1 선결 조건(and)
- 같은 클래스에서 생선된 메서드
- 메서드의 이름이 같을 것
* 파라미터의 개수or자료형or순서가 다르면 성립*
- 접근제한자, 반환형, 파라미터의 변수명, 메서드 본문내용은 관련 없음

5.2 메서드 오버로딩 성립 조건(or)
- 파라미터(매개변수)의 개수가 다르면 성립
	public void m1(){}
	public void m1(int a){}
- 파라미터의 개수가 같고, 파라미터의 자료형이 다르면 성립
	public void m1(int a, long b){}
	public void m1(int a, dog c){}
- 파라미터의 개수가 같고, 파라미터의 자료형도 같을 때 파라미터 자료형의 배치 순서가 다르면 성립 
	public void m1(int a dog c){}
	public void m1(dog c, int a){}

5.3 메서드 오버로딩을 사용
- 메서드들의 전반적인 기능이 같은데 파라미터의 자료형이 다를 때
- 장점: 메서드 호출 시 파라미터의 자료형에 구애받지 않고 호출

==메서드 오버로딩 Vs 메서드 오버라이딩에 대해 설명.

6. 메서드 오버라이딩 (추후에)
- 상속 관계가 성립하는 두 클래스에서 자식 클래스가 부모 클래스의 메서드 내용을 재정의 하는 것을 의미
- 재정의: 수정/삭제/추가 

==오버로딩과 오버라이딩의 차이

﻿+ 생성자
- class의 field를 초기화하는 class의 구성요소
- new 생성자(); 호출할 때 마다 객체 생성(객체 = 변수명 = 레퍼런스)
- 접근제한자 생성자명(){}  // 생성자명은 클래스명과 같다,
- [Ctrl + Space + Enter 디폴트생성자]
- 디폴트 생성자와 사용자 생성자로 나눈다

+ 디폴트 생성자
- 파라미터가 없는 생성자
- 클래스에 생성자가 없으면, 디폴트 생성자 제공
- 클래스에 사용자 생성자가 있으면, 디폴트 생성자 미제공
super(); // 생략되어있음.(보이지 않지만 존재)

+ 사용자 생성자
- 파라미터가 있는 생성자
- 우클릭(Shift + Alt + S) Source - Generate - Constructor - Using - fields - 체크
*사용자 생성자가 있으면 디폴트 생성자는 지원되지 않음

+생성자의 기능
- 클래스 멤버변수 초기화
- 참조자료형의 자료형에 맞는 값을 제공

- 반환형이 없다
- Ctrl + Space로 바로 만들 수 있다

+ 생성자 공식
접근제한자 생성자명(){}

this.변수명
- 해당 클래스의 field를 가르킴
- 지역변수와 field가 같을 때 지역변수를 우선인식해서 this.를 쓴다
this()
- 다른 생성자 호출
- 생성자가 오버로딩되면 생성자 간의 중복 코드가 발생할 때 사용
- 초기화 내용을 한 생성자에 몰아서 작성
- this(변수1, 변수2, 변수3....);
- 생성자 본문 첫 줄에서만 사용가능(그래서 메소드호출이 더 많이 사용됨)

﻿생성자 선언에 다른 생성자가 들어갈 경우
연습 문제)1

public Person(String name, String ssn, String address, int dateOfBirth, Car car, Dog dog, Cat cat) {
	...	this.car = car;
		this.dog = dog;
		this.cat = cat;

Person park = new Person("박씨", "m-01", "경기도", 901223, new Car("승용차"),new Dog(), new Cat());

연습 문제)2
Person kim1 = new Person("s01", new String("kim"), 44, "서울", "lec", new Dog("개똥이", 55, "개주인"), null);
		Person park = new Person("a12", "박", 31, "서울", "학생", new Dog("멍멍이", 3, "주인박씨"), null);
		park.setAge(99);
		park.getDog().dogInfo();
		
		park.setDog(new Dog("두부", 5, "박씨"));
		park.getDog().setName("잔디");
		String dogName = park.getDog().getName();
		System.out.println(dogName);
		park.getDog().dogInfo();
		kim1.getDog().dogInfo();
			

11.26) 08-------------------------------------------------------------------------------------------------

= 클래스의 구성 요소 =
- 멤버 변수
 필드영역에서는 변수 대입이 불가.
 필드영역에서는 메서드 호출 불가.

- 생성자

- (멤버) 메서드
 메서드 영역에서 메서드 생성 불가.(호출은 가능)

* 멤버변수나 메서드를 호출(사용)하려면, 반드시
객체(=해당 변수나 메서드를 포함하고 있는 참조자료형 변수)가 있어야 한다.

1. 생성자의 역할
- 멤버 변수의 초기화
- 객체(=참조자료형의 변수)의 생성 때, 자료형에 맞는 값으로 사용됨.
- Ctrl + Space로 바로 만들 수 있다

2. 멤버 변수의 역할
- 객체의 구성요소를 표현

3. 지역 변수
- 메서드 안에서 중복되는 값을 표현(수정 용의)

4. 메서드의 역할
- 객체의 기능(능력)을 표현
- 클래스 안에서 중복되는 값들(복수형)을 표현

5. 디폴트 생성자(무조껀 만든다)
- 사용자 생성자가 없을 때는 존재
- 사용자 생성자가 있을 때는 없다

6. this
- 객체 자기자신
- 지역 변수와 멤버 변수가 이름이 같으면 지역변수를 우선인식하기 때문에 사용
- this.멤버변수

this( ) 
- 생성자 호출
- 해당 클래스 안에서만
- 다른 생성자의 첫번째 라인에서만 호출 -> 대신 메서드를 사용, 제약이 없음

=========

= 객체와 클래스

Object = 자바의 최상위 부모클래스

객체 = object(오브젝트) = instance(인스턴스) [= bean(빈) = entity = domain]

1. 객체는 명사다.
 - 한라산
ex) Mountain hanlasin = new Mountatin("한라산");

 - 자동차
ex) Car bmw = new = Car();

2. heap 메모리에 저장된 데이터

3. 실체


4. 객체 생성법
- 참조자료형 변수명(=객체명=레퍼런스) = new 생성자();
5. 객체 사용법
- 객체가 갖고 있는 자원(변수, 메서드)을 사용하는 방법
-> 객체명.변수명
-> 객체명.메서드명()

= 클래스(= 객체의 설계도)

1. 객체의 구성 요소를 표현한 자료
2. 객체 생성법을 표현한 자료
3. 객체의 기능을 표현한 자료

4. 설계도
ex) 붕어빵틀(클래스) : 붕어빵(객체)
ex) 자동차설계도(클래스) : 자동차(객체)

5. 클래스의 구성 요소
멤버 필드(변수/상수), 생성자, 메서드

6. 클래스는 단독으로 실행되지 않는다. 
 -> 객체를 생성하여 작업할 수 있다.

7. class 키워드가 있어야 클래스이다.

